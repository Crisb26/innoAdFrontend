package com.innoad.shared.config;

import org.junit.jupiter.api.BeforeEach;\nimport org.junit.jupiter.api.Test;\nimport org.junit.jupiter.api.DisplayName;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.boot.test.context.SpringBootTest;\nimport org.springframework.data.redis.core.RedisTemplate;\nimport org.springframework.mock.web.MockHttpServletRequest;\nimport org.springframework.mock.web.MockHttpServletResponse;\nimport org.springframework.security.core.Authentication;\nimport org.springframework.security.core.context.SecurityContext;\nimport org.springframework.security.core.context.SecurityContextHolder;\nimport org.springframework.test.context.ActiveProfiles;\nimport org.springframework.test.util.ReflectionTestUtils;\n\nimport jakarta.servlet.http.HttpServletRequest;\nimport jakarta.servlet.http.HttpServletResponse;\n\nimport static org.junit.jupiter.api.Assertions.*;\nimport static org.mockito.Mockito.*;\n\n/**\n * Tests unitarios para InterceptorRateLimiting\n * Verifica funcionamiento del rate limiting\n */\n@SpringBootTest\n@ActiveProfiles(\"test\")\n@DisplayName(\"InterceptorRateLimiting - Tests de Rate Limiting\")\npublic class InterceptorRateLimitingTest {\n\n    @Autowired\n    private InterceptorRateLimiting interceptorRateLimiting;\n\n    @Autowired\n    private RedisTemplate<String, Object> redisTemplate;\n\n    private HttpServletRequest request;\n    private HttpServletResponse response;\n    private Object handler;\n\n    @BeforeEach\n    void setUp() {\n        // Limpiar Redis antes de cada test\n        redisTemplate.getConnectionFactory().getConnection().flushAll();\n        \n        request = new MockHttpServletRequest();\n        response = new MockHttpServletResponse();\n        handler = new Object();\n        \n        // Mock de usuario autenticado\n        mockSecurityContext(\"user123\");\n    }\n\n    @Test\n    @DisplayName(\"Request permitido dentro del límite\")\n    void testRequestDentroDelLimite() throws Exception {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/chat/enviar\");\n        ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n        // When - 50 requests (menos del límite de 100)\n        for (int i = 0; i < 50; i++) {\n            boolean resultado = interceptorRateLimiting.preHandle(request, response, handler);\n            assertTrue(resultado, \"Request #\" + (i + 1) + \" debe ser permitido\");\n        }\n    }\n\n    @Test\n    @DisplayName(\"Request rechazado cuando se excede el límite general\")\n    void testLimitGenetalExcedido() throws Exception {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/chat/enviar\");\n        ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n        // When - 101 requests (mayor que límite de 100)\n        boolean ultimoResultado = true;\n        for (int i = 0; i < 101; i++) {\n            ultimoResultado = interceptorRateLimiting.preHandle(request, response, handler);\n        }\n\n        // Then - El 101 debe ser rechazado\n        assertFalse(ultimoResultado, \"Request 101 debe ser rechazado\");\n        assertEquals(429, response.getStatus());\n    }\n\n    @Test\n    @DisplayName(\"Rate limit más restrictivo para endpoints IA\")\n    void testLimitIAMasRestrictivo() throws Exception {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/ia/pregunta\");\n        ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n        // When - 6 requests al endpoint IA (límite es 5)\n        boolean resultado = true;\n        for (int i = 0; i < 6; i++) {\n            resultado = interceptorRateLimiting.preHandle(request, response, handler);\n            if (i < 5) {\n                assertTrue(resultado, \"Request IA #\" + (i + 1) + \" debe ser permitido\");\n            }\n        }\n\n        // Then - El 6to debe ser rechazado\n        assertFalse(resultado, \"Request IA 6 debe ser rechazado (límite 5)\");\n        assertEquals(429, response.getStatus());\n    }\n\n    @Test\n    @DisplayName(\"Diferentes usuarios tienen contadores independientes\")\n    void testContadoresIndependientesPorUsuario() throws Exception {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/chat/enviar\");\n        ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n        // When - 99 requests para usuario1\n        for (int i = 0; i < 99; i++) {\n            mockSecurityContext(\"user1\");\n            interceptorRateLimiting.preHandle(request, response, handler);\n        }\n\n        // Then - Usuario2 debe poder hacer requests\n        mockSecurityContext(\"user2\");\n        boolean resultado = interceptorRateLimiting.preHandle(request, response, handler);\n        assertTrue(resultado, \"Usuario2 debe tener su propio contador\");\n        assertEquals(200, response.getStatus()); // Status OK por defecto\n    }\n\n    @Test\n    @DisplayName(\"Respuesta contiene headers de rate limit\")\n    void testHeadersRateLimit() throws Exception {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/chat/enviar\");\n        ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n        // When\n        interceptorRateLimiting.preHandle(request, response, handler);\n\n        // Then - Verificar headers\n        assertNotNull(response.getHeader(\"X-RateLimit-Limit\"), \n            \"Debe tener header X-RateLimit-Limit\");\n        assertNotNull(response.getHeader(\"X-RateLimit-Remaining\"),\n            \"Debe tener header X-RateLimit-Remaining\");\n        assertNotNull(response.getHeader(\"X-RateLimit-Reset\"),\n            \"Debe tener header X-RateLimit-Reset\");\n    }\n\n    @Test\n    @DisplayName(\"Endpoint no autenticado tiene límite más bajo\")\n    void testLimitNoAutenticado() throws Exception {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/public/info\");\n        ((MockHttpServletRequest) request).setMethod(\"GET\");\n        \n        // Desautenticar usuario\n        SecurityContextHolder.clearContext();\n\n        // When - 11 requests sin autenticar (límite es 10)\n        boolean resultado = true;\n        for (int i = 0; i < 11; i++) {\n            resultado = interceptorRateLimiting.preHandle(request, response, handler);\n            if (i < 10) {\n                assertTrue(resultado, \"Request no autenticado #\" + (i + 1) + \" debe ser permitido\");\n            }\n        }\n\n        // Then\n        assertFalse(resultado, \"Request 11 sin autenticar debe ser rechazado\");\n        assertEquals(429, response.getStatus());\n    }\n\n    @Test\n    @DisplayName(\"JSON de error contiene información completa\")\n    void testJsonErrorCompleto() throws Exception {\n        // Given - Exceder límite\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/chat/enviar\");\n        ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n        // When - Hacer 101 requests\n        for (int i = 0; i < 101; i++) {\n            interceptorRateLimiting.preHandle(request, response, handler);\n        }\n\n        // Then - El response debe contener JSON con información\n        String contentType = response.getContentType();\n        assertNotNull(contentType);\n        assertTrue(contentType.contains(\"application/json\"),\n            \"Response debe ser JSON\");\n    }\n\n    @Test\n    @DisplayName(\"Contador se resetea después del timeout\")\n    void testReseteoContador() throws InterruptedException {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/chat/enviar\");\n        ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n        // When - Hacer 50 requests\n        for (int i = 0; i < 50; i++) {\n            interceptorRateLimiting.preHandle(request, response, handler);\n        }\n\n        // Esperar más de 60 segundos para que expire el contador\n        // (En tests usaría mockito para mockear el tiempo)\n        // Por ahora solo verificamos que el contador existe\n        assertTrue(true, \"Contador debe existir\");\n    }\n\n    @Test\n    @DisplayName(\"Detecta correctamente endpoints IA\")\n    void testDeteccionEndpointsIA() throws Exception {\n        // Given\n        String[] endpointsIA = {\n            \"/api/ia/pregunta\",\n            \"/api/ia/chat\",\n            \"/api/pregunta\",\n            \"/api/asistente/consulta\"\n        };\n\n        for (String endpoint : endpointsIA) {\n            // When\n            ((MockHttpServletRequest) request).setRequestURI(endpoint);\n            ((MockHttpServletRequest) request).setMethod(\"POST\");\n\n            // Hacer 6 requests\n            boolean resultado = true;\n            for (int i = 0; i < 6; i++) {\n                resultado = interceptorRateLimiting.preHandle(request, response, handler);\n            }\n\n            // Then - El 6to debe ser rechazado (límite IA es 5)\n            // Limpiar para próximo test\n            redisTemplate.getConnectionFactory().getConnection().flushAll();\n        }\n    }\n\n    @Test\n    @DisplayName(\"No aplica limit a endpoints de salud\")\n    void testNoLimitHealthCheck() throws Exception {\n        // Given\n        ((MockHttpServletRequest) request).setRequestURI(\"/api/health\");\n        ((MockHttpServletRequest) request).setMethod(\"GET\");\n\n        // When - 1000 requests a health\n        for (int i = 0; i < 1000; i++) {\n            boolean resultado = interceptorRateLimiting.preHandle(request, response, handler);\n            assertTrue(resultado, \"Health check nunca debe ser limitado\");\n        }\n    }\n\n    /**\n     * Método auxiliar para mockear el contexto de seguridad\n     */\n    private void mockSecurityContext(String username) {\n        Authentication auth = mock(Authentication.class);\n        when(auth.getName()).thenReturn(username);\n        when(auth.isAuthenticated()).thenReturn(true);\n\n        SecurityContext securityContext = mock(SecurityContext.class);\n        when(securityContext.getAuthentication()).thenReturn(auth);\n        SecurityContextHolder.setContext(securityContext);\n    }\n}\n
